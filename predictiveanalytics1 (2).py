# -*- coding: utf-8 -*-
"""PredictiveAnalytics1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-Dzujv_j35TKIF1KWUEsv9pVjxRvyoD5

*   Nama : Ihsan Ananda Pratama
*   Domisili : Kabupaten Jakarta Barat
*   Instansi : PT Indocyber Global Technology

# **Import Library**
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import zipfile,os
import matplotlib.pyplot as plt
import pandas as pd
# %matplotlib inline
import seaborn as sns
import pickle
from sklearn.metrics import accuracy_score
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import  OneHotEncoder
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

"""# **Data Loading**"""

# Define dataframe
url = 'https://raw.githubusercontent.com/IhsanAnanda/PredictiveAnalytics/main/milknew.csv'
df = pd.read_csv(url)
df.head()

df.info()

# Data plotting
target_counts = df['Grade'].value_counts()
fig, ax = plt.subplots(figsize=(6, 6))
ax.pie(target_counts, labels=target_counts.index, autopct='%1.1f%%')

# Add a title and description
ax.set_title('Distribution of Milk Grade(Target Class)')

# Show the plot
plt.show()

"""Dataset ini terdiri dari 3 target class dan 1059 baris data. Target class tersebut terdiri dari low, medium, high yang mengambarkan kualitas susu. Berdasarkan visualisasi menggunakan diagram lingkaran(pie chart) diatas yang dilampirkan dari 1059 data terdapat 40,5%(429 data) dimiliki oleh kelas low, 35.3%(374 data) dimiliki oleh kelas medium, dan 24.2%(256 data) dimiliki oleh kelas high.

# **Data Understanding**

*   Data Description
"""

df.describe()

"""*   Replace 0 and 1 values, hal ini dilakukan untuk mempermudah analisis dataset"""

df.columns

df['Taste'] = df['Taste'].replace({0: 'Bad', 1: 'Good'})
df['Odor'] = df['Odor'].replace({0: 'Bad', 1: 'Good'})
df.rename(columns={'Fat ': 'Fat'}, inplace=True)
df['Fat'] = df['Fat'].replace({0: 'Bad', 1: 'Good'})
df['Turbidity'] = df['Turbidity'].replace({0: 'Bad', 1: 'Good'})
df.head()

"""*   Univariate Analysis"""

numerical_features = ['pH', 'Temprature', 'Colour']
categorical_features = ['Taste', 'Odor', 'Fat', 'Turbidity']

# Fitur Taste
feature = categorical_features[0]
count = df[feature].value_counts()
percent = 100*df[feature].value_counts(normalize=True)
result = pd.DataFrame({'Total Sample':count, 'Percentage':percent.round(1)})
print(result)
count.plot(kind='bar', title=feature);

"""

> Dari grafik diatas menunjukkan bahwa lebih dari 50% total data dimiliki oleh susu dengan rasa cukup enak atau memenuhi standar (taste good). Dapat disimpulkan bahwa rata-rata dari dataset yang dimiliki memiliki rasa susu yang cukup enak.

"""

# Fitur Odor
feature = categorical_features[1]
count = df[feature].value_counts()
percent = 100*df[feature].value_counts(normalize=True)
result = pd.DataFrame({'Total Sample':count, 'Percentage':percent.round(1)})
print(result)
count.plot(kind='bar', title=feature);

"""

> Dari grafik diatas menunjukkan bahwa lebih dari 50% total susu yang terdapat pada dataset memiliki bau  yang kurang sedap atau tidak memenuhi standar. Haal ini menunjukkan bahwa rata-rata dari dataset yang diperoleh memiliki bau yang kurang sedap.

"""

# Fitur Fat
feature = categorical_features[2]
count = df[feature].value_counts()
percent = 100*df[feature].value_counts(normalize=True)
result = pd.DataFrame({'Total Sample':count, 'Percentage':percent.round(1)})
print(result)
count.plot(kind='bar', title=feature);

"""

> Berdasarkan dari grafik diatas lebih dari 60% total dataset memiliki kadar lemak yang memenuhi standar. Yang berarti dari dataset yang diperoleh lebih dari 700 sample data telah memenuhi standar kadar lemak susu yang sehat.

"""

# Fitur Turbidity
feature = categorical_features[3]
count = df[feature].value_counts()
percent = 100*df[feature].value_counts(normalize=True)
result = pd.DataFrame({'Total Sample':count, 'Percentage':percent.round(1)})
print(result)
count.plot(kind='bar', title=feature);

"""

> Dari grafik diatas dapat disimpulkan bahwa perbandingan tingkat kekeruhan susu dari dataset cukup seimbang. Hal ini cukup bagus untuk menjadi pertimbangan model dalam proses training karena pembagian dataset yang seimbang.

"""

# Numerical Features
df.hist(bins=50, figsize=(12,8))
plt.show()

"""> Berdasarkan histogram diatas nilai frekuensi pH terbanyak berada diantara 6 hingga 7, lebih dari 60% data dari dataset memiliki suhi dibawah 50&deg;F, dan nilai tingkat warna susu didominasi dengan nilai 255. Dari grafik diatas dapat disimpulkan bahwa persebaran data numerical untuk fitur pH, Temprature, dan Colour tidak merata.

*   Multivariate Analysis
"""

df.info()

# Categorial Features
for col in categorical_features:
  sns.set(style="darkgrid")
  plt.figure(figsize=(6, 4))
  sns.countplot(data=df, x=col, hue="Grade")
  plt.title('Bar Diagram of {} vs {}'.format(col, 'Grade'))
  plt.legend(title="Grade")
  plt.show()

"""

> Analisis multivariate digunakan dengan cara menggambarkan diagram batang dari keterkaitan antara fitur ketegorial pada dataset dan target kelas. Diagram tersebut menggambarkan jumlah pada setiap fitur dengan target kelas yaitu kualitas susu. Kesimpulan dari diagram diatas adalah:


*   Susu dengan rasa yang memenuhi standar(good) memiliki presentase kelas terbanyak di kualitas low, hal ini membuktikan bahwa kualitas susu tidak bergantung hanya pada rasa susu.
*   Bau susu dengan jumlah kelas yang mendominasi dataset diperoleh oleh bau yang tidak memenuhi standar dengan kelas kualitas susu medium, hal ini juga membutikan bahwa kulitas susu tidak bergantung hanya pada bau susu.
*   Untuk fitur fat pada dataset yang digambarkan dari grafik diatas dapat disimpulkan bahwa kualutas susu bergantung dari kadar lemak yang terdapat pada susu, tidak terdapatnya susu berkualitas tinggi(high) dengan kadar lemak yang buruk(bad) membuktikan bahwa kualitas susu dipengaruihi oleh kadar lemak pada susu. Pada fitur ini juga didominasi oleh susu dengan kadar lemak yang memenuhi standar.
*   Selanjutnya untuk fitur tingkat kekeruhan susu didominasi oleh tingkat kekeruhan yang tidak memenuhi standar memiliki kelas kualitas medium dan susu dengan tingkat kekeruhan memenuhi standar didominasi oleh kualitas low. Hal ini menunjukkan bahwa tingkat kekeruhan susu cukup berpengaruh dalam menentukan kualitas susu.





"""

# Numerical Features
sns.pairplot(df, hue="Grade", diag_kind = 'kde')

"""

> Untuk melakukan Multivariate Analysis pada fitur numerical saya menggunakan pairplot dengan kualitas susu sebagai warna plot. Dapat dilihat pada grafik plotting diatas bahwa peserbaran data dataset tidak merata untuk fitur categorial. Kualitas susu tinggi(high) dan menengah(medium) cenderung memiliki pesebaran data yang tidak berbeda jauh atau dapat disebut lebih cenderung berkumpul. Sementara itu untuk data dengan kualitas susu renda(low) cenderung memiliki data yang tersebar namun cenderung membentuk pola garis yang berarti data ini cenderung constant perubahan nilainya.

"""

# Analisis Heatmap
plt.figure(figsize=(10, 8))
correlation_matrix = df.corr().round(2)
sns.heatmap(data=correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5, )
plt.title("Correlation Matrix untuk Fitur Numerik ", size=20)

"""> Dari hasil diagram heatmap diatas dapat dilihat bahwa setiap numerical fitur pada dataset memiliki korelasi yang rendah. Korelasi terendah dimiliki oleh fitur warna(colour). Namun agar model tetap dapat melakukan pelatihan dengan baik, maka fitur dengan korelasi terendah tidak akan dihilangkan pada studi kasus ini.

#**Data Preparation**

*   Missing Value
"""

pH = (df.pH == 0).sum()
temprature = (df.Temprature == 0).sum()
colour = (df.Colour == 0).sum()
Turbidity = (df.Turbidity.isnull()).sum()
Fat = (df.Fat.isnull()).sum()
Odor = (df.Odor.isnull()).sum()
Taste = (df.Taste.isnull()).sum()
     
print("Nilai 0 di kolom pH ada: ", pH)
print("Nilai 0 di kolom temprature ada: ", temprature)
print("Nilai 0 di kolom colour ada: ", colour)
print("Nilai null di kolom Turbidity ada: ", Turbidity)
print("Nilai null di kolom Fat ada: ", Fat)
print("Nilai null di kolom Odor ada: ", Odor)
print("Nilai null di kolom Taste ada: ", Taste)

"""> Setelah dilakukan pengecekan tidak ada data yang bernilai 0 pada kolom setiap fitur pada dataset maka tidak perlu dilakukannya tahap preprocessing untuk menghilangkan data yang kosong atau null.

*   One Hot Encoding
"""

df = pd.concat([df, pd.get_dummies(df['Taste'], prefix='Taste')],axis=1)
df = pd.concat([df, pd.get_dummies(df['Odor'], prefix='Odor')],axis=1)
df = pd.concat([df, pd.get_dummies(df['Fat'], prefix='Fat')],axis=1)
df = pd.concat([df, pd.get_dummies(df['Turbidity'], prefix='Turbidity')],axis=1)
df.drop(['Taste','Odor','Fat', 'Turbidity'], axis=1, inplace=True)
df.head()

"""> Proses one hot encoding tersebut dilakukan dengan tujuan merubah kembali fitur yang bernilai kategorial kembali menjadi numerical. Fitur yang diubah adalah rasa, suhu, bau, kadar lemak, dan kekeruhan.

*   Train-Test Spliting
"""

X = df.drop(["Grade"],axis =1)
y = df["Grade"]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 123)

print(f'Total banyak sample data dari dataset: {len(X)}')
print(f'Total banyak sample yang digunakan sebagai data training: {len(X_train)}')
print(f'Total banyak sample yang digunakan sebagai data uji: {len(X_test)}')

"""> Pembagian data training dan dataset dilakukan dengan rasio 20% digunakan sebagai data uji dan 80% sebagai data latih. Detail pembagian dataset dapat dilihat pada hasil kode diatas.

*   Data Normalization
"""

scaler = StandardScaler()
scaler.fit(X_train[numerical_features])
X_train[numerical_features] = scaler.transform(X_train.loc[:, numerical_features])
X_train[numerical_features].head()

X_train[numerical_features].describe().round(4)

"""> Pada tahapan ini dilakukan proses untuk melakukan normalisasi data. Proses ini dilakukan untuk menghasilkan model yang lebih akurat dan membentuk data agar memiliki range atau rentang data yang lebih kecil. Tahapan ini menormalisasi dataset pada kolom pH, suhu, dan warna. Algoritma normalisasi data yang digunakan adalah standard scaler.

# **Model Development**

> Pada tahapan ini dilakukan pembentukan model machine learning yang akan digunakan. Pada penelitian kali ini digunakanlah algoritma K-Nearest Neighbors(KNN) dan Random Forest(RF). Algoritma KNN digunakan karena ini adalah salah satu algoritma KNN yang mudah untuk dipahami dan diterapkan, selain itu model ini tidak memerlukan proses training yang lama hanya membandingkan jarak kemiripan data yang diuji dengan data training. Sementara itu RF digunakan karena algoritma ini merupakan algoritma yang banyak digunakan untuk melakukan proses klasifikasi, meskipun memiliki algoritma yang lebih rumit dari KNN. Di penelitian ini akan mencoba untuk membandingkan kedua algoritma tersebut manakah yang memiliki peforma terbaik berdasarkan akurasi tertinggi.
"""

# Evaluation DataFrame
models = pd.DataFrame(index=['train_accuracy', 'test_accuracy'], columns=['KNN', 'RandomForest'])

"""

*   KNN

"""

knn = KNeighborsClassifier(n_neighbors=10)
knn.fit(X_train, y_train)
     
models.loc['train_mse','KNN'] = accuracy_score(y_pred = knn.predict(X_train), y_true=y_train)

"""

*   RF

"""

RF = RandomForestClassifier(n_estimators=50, max_depth=16, random_state=55, n_jobs=-1)
RF.fit(X_train, y_train)
 
models.loc['train_mse','RandomForest'] = accuracy_score(y_pred=RF.predict(X_train), y_true=y_train)

"""# **Evaluation**

> Tahapan ini adalah proses mengevaluasi model untuk memilih model terbaik berdasarkan akurasi tertinggi. Tahapan ini akan membandingkan akurasi kedua model bersadarkan akurasi data training dan data uji.
"""

# Normalisasi data uji
X_test.loc[:, numerical_features] = scaler.transform(X_test[numerical_features])

# Accuracy DataFrame
accuracy = pd.DataFrame(columns=['train', 'test'], index=['KNN','RF'])
     
# Model dictionary
model_dict = {'KNN': knn, 'RF': RF}
     
# Getting Accuracy
for name, model in model_dict.items():
  accuracy.loc[name, 'train'] = accuracy_score(y_true=y_train, y_pred=model.predict(X_train)) 
  accuracy.loc[name, 'test'] = accuracy_score(y_true=y_test, y_pred=model.predict(X_test))
     
# Show result
accuracy

fig, ax = plt.subplots()
accuracy.sort_values(by='test', ascending=False).plot(kind='barh', ax=ax, zorder=3)
ax.grid(zorder=0)

"""

> Berdasarkan dari grafik tersebut didapatkan bahwa model dengan akurasi terbaik diperoleh oleh Random Forest. Model tersebut mendapatkan akurasi hingga 100% untuk data training dan data uji dari kualitas susu. 

"""

# Implement Algorithm
prediksi = X_test.iloc[:1].copy()
pred_dict = {'y_true':y_test[:1]}
for index, model in model_dict.items():
  pred_dict['prediksi_'+index] = model.predict(prediksi)
     
pd.DataFrame(pred_dict)

# Export Model
filename = 'model.pkl'
with open(filename, 'wb') as file:
    pickle.dump(RF, file)

